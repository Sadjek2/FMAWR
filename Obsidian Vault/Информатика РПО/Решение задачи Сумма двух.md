
## Проблема

Нам нужно найти два целых числа в массиве, сумма которых равна заданному целевому числу. Условия задачи предполагают, что:

1. Существует только одно решение.
2. Размер массива больше 2 и меньше 10^4.
3. Числа в массиве и целевое число находятся в диапазоне от -10^9 до 10^9.

## Алгоритм

Для решения этой задачи мы можем использовать два подхода:

1. **Перебор всех пар**: Этот метод включает в себя перебор всех возможных пар чисел в массиве и проверку их суммы. Однако этот метод имеет временную сложность O(n^2), что может быть неэффективно для больших массивов.
    
2. **Использование хеш-таблицы**: Этот метод более эффективен и имеет временную сложность O(n). Мы можем пройти по массиву и для каждого числа вычислить его "комплемент" (разность между целевым числом и текущим числом). Затем мы проверяем, существует ли этот комплемент в хеш-таблице. Если он существует, мы нашли нужную пару.
    

## Реализация

Вот реализация второго подхода на Python:

from typing import List


```python 
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # Создаем словарь для хранения чисел и их индексов
        num_to_index = {}
        
        # Проходим по массиву
        for i, num in enumerate(nums):
            # Вычисляем комплемент
            complement = target - num
            
            # Проверяем, есть ли комплемент в словаре
            if complement in num_to_index:
                return [num_to_index[complement], i]
            
            # Сохраняем текущее число и его индекс в словаре
            num_to_index[num] = i
        
        # Если пара не найдена, возвращаем [-1, -1]
        return [-1, -1]

# Пример использования
solution = Solution()
numbers = [3, 42, 15, 2]
target = 18
result = solution.twoSum(numbers, target)
print(result)  # Вывод: [0, 2] так как nums[0] + nums[2] = 3 + 15 = 18
```

## Объяснение кода

1. **Импортируем необходимые модули**: Мы используем `List` из модуля `typing` для аннотации типов.
2. **Создаем класс `Solution`**: Внутри класса определяем метод `twoSum`, который принимает массив `nums` и целевое число `target`.
3. **Создаем словарь `num_to_index`**: Этот словарь будет хранить числа и их индексы, что позволяет нам быстро проверять наличие комплемента.
4. **Итерация по массиву**: Мы проходим по каждому элементу массива, вычисляем его комплемент и проверяем, есть ли он в словаре.
5. **Возвращаем индексы**: Если комплемент найден, возвращаем индексы текущего числа и комплемента.
6. **Обработка случая, когда пара не найдена**: Если пара не найдена, возвращаем `[-1, -1]`.

## Примечания

- Данный алгоритм работает за линейное время O(n) и использует O(n) дополнительной памяти для хранения хеш-таблицы.
- Убедитесь, что входные данные соответствуют условиям задачи, чтобы избежать ошибок.