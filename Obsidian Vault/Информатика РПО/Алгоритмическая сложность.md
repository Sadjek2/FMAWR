Алгоритмическая сложность - это функция зависимости объема работы алгоритма от размера обрабатываемых данных.
Она позволяет оценить как изменится время исполнения и объем занятой памяти в зависимости от размера входных данных.

### Концепция (нотация) "Big O"

**Big O** (O-нотация) — это математическая нотация, используемая для описания асимптотической сложности алгоритмов. Она позволяет оценить, как время выполнения или объем памяти алгоритма изменяется в зависимости от размера входных данных. Big O фокусируется на наиболее значимых терминах и игнорирует константы и менее значимые члены, что позволяет упростить анализ. Например, если время выполнения алгоритма описывается как (T(n) = 3n^2 + 2n + 5), то в нотации Big O это будет записано как (O(n^2)), поскольку при больших (n) именно (n^2) будет определять рост времени выполнения.

### Константная сложность

**Константная сложность** обозначается как (O(1)). Это означает, что время выполнения алгоритма не зависит от размера входных данных. Например, доступ к элементу массива по индексу или выполнение фиксированного количества операций всегда занимает одинаковое время, независимо от размера массива.

### Линейная сложность

**Линейная сложность** обозначается как (O(n)). Это означает, что время выполнения алгоритма пропорционально размеру входных данных. Например, если алгоритм проходит по всем элементам массива и выполняет фиксированное количество операций для каждого элемента, то время выполнения будет расти линейно с увеличением размера массива.

### Квадратичная сложность

**Квадратичная сложность** обозначается как (O(n^2)). Это означает, что время выполнения алгоритма пропорционально квадрату размера входных данных. Например, алгоритмы, которые используют два вложенных цикла для обработки всех пар элементов (например, сортировка пузырьком), имеют квадратичную сложность. Если размер входных данных удваивается, время выполнения увеличивается в четыре раза.

### Логарифмическая сложность

**Логарифмическая сложность** обозначается как (O(\log n)). Это означает, что время выполнения алгоритма растет медленнее, чем линейно, и пропорционально логарифму размера входных данных. Примером алгоритма с логарифмической сложностью является бинарный поиск, который делит массив пополам на каждом шаге, что позволяет значительно сократить количество необходимых операций по сравнению с линейным поиском.